---
title: Setup
---

# Setup

There are currently a few integrations to choose from.

## Webpack

1/ Install the dependencies.

```bash
$ npm install @vanilla-extract/css @vanilla-extract/webpack-plugin
```

2/ Add the [webpack](https://webpack.js.org) plugin.

> ðŸ’¡ This plugin accepts an optional [configuration object](#configuration).

```js
// webpack.config.js

const {
  VanillaExtractPlugin
} = require('@vanilla-extract/webpack-plugin');

module.exports = {
  plugins: [new VanillaExtractPlugin()]
};
```

3/ If you'd like automatic debuggable identifiers, you can add the [Babel](https://babeljs.io) plugin.

```bash
$ npm install @vanilla-extract/babel-plugin
```

```json
{
  "plugins": ["@vanilla-extract/babel-plugin"]
}
```

> You'll need to ensure you're handling CSS files in your webpack config.

For example:

```js
// webpack.config.js

const {
  VanillaExtractPlugin
} = require('@vanilla-extract/webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  plugins: [
    new VanillaExtractPlugin(),
    new MiniCssExtractPlugin()
  ],
  module: {
    rules: [
      {
        test: /\.vanilla\.css$/i, // Targets only CSS files generated by vanilla-extract
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: require.resolve('css-loader'),
            options: {
              url: false // Required as image imports should be handled via JS/TS import statements
            }
          }
        ]
      }
    ]
  }
};
```

## esbuild

1/ Install the dependencies.

```bash
$ npm install @vanilla-extract/css @vanilla-extract/esbuild-plugin
```

2/ Add the [esbuild](https://esbuild.github.io/) plugin to your build script.

> ðŸ’¡ This plugin accepts an optional [configuration object](#configuration).

```js
// bundle.js

const {
  vanillaExtractPlugin
} = require('@vanilla-extract/esbuild-plugin');

require('esbuild')
  .build({
    entryPoints: ['app.ts'],
    bundle: true,
    plugins: [vanillaExtractPlugin()],
    outfile: 'out.js'
  })
  .catch(() => process.exit(1));
```

> Please note: There are currently no automatic readable class names during development. However, you can still manually provide a debug ID as the last argument to functions that generate scoped styles, e.g. `export const className = style({ ... }, 'className');`

3/ Process CSS

As [esbuild](https://esbuild.github.io/) currently doesn't have a way to process the CSS generated by vanilla-extract, you can optionally use the `processCss` option.

For example, to run autoprefixer over the generated CSS.

```js
// bundle.js

const {
  vanillaExtractPlugin
} = require('@vanilla-extract/esbuild-plugin');
const postcss = require('postcss');
const autoprefixer = require('autoprefixer');

async function processCss(css) {
  const result = await postcss([autoprefixer]).process(
    css,
    {
      from: undefined /* suppress source map warning */
    }
  );

  return result.css;
}

require('esbuild')
  .build({
    entryPoints: ['app.ts'],
    bundle: true,
    plugins: [
      vanillaExtractPlugin({
        processCss
      })
    ],
    outfile: 'out.js'
  })
  .catch(() => process.exit(1));
```

## Vite

1/ Install the dependencies.

```bash
$ npm install @vanilla-extract/css @vanilla-extract/vite-plugin
```

2/ Add the [Vite](https://vitejs.dev/) plugin to your Vite config.

> ðŸ’¡ This plugin accepts an optional [configuration object](#configuration).

```js
// vite.config.js

import { vanillaExtractPlugin } from '@vanilla-extract/vite-plugin';

export default {
  plugins: [vanillaExtractPlugin()]
};
```

> Please note: There are currently no automatic readable class names during development. However, you can still manually provide a debug ID as the last argument to functions that generate scoped styles, e.g. `export const className = style({ ... }, 'className');`

## Next.js

1/ Install the dependencies.

```bash
npm install @vanilla-extract/css @vanilla-extract/babel-plugin @vanilla-extract/next-plugin
```

2/ If you don't have a `next.config.js` file in the root of your project, create one. Add the [Next.js](https://nextjs.org) plugin to your `next.config.js` file.

> ðŸ’¡ This plugin accepts an optional [configuration object](#configuration).

```js
const {
  createVanillaExtractPlugin
} = require('@vanilla-extract/next-plugin');
const withVanillaExtract = createVanillaExtractPlugin();

/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = withVanillaExtract(nextConfig);
```

If required, this plugin can be composed with other plugins.

```js
const {
  createVanillaExtractPlugin
} = require('@vanilla-extract/next-plugin');
const withVanillaExtract = createVanillaExtractPlugin();

const withMDX = require('@next/mdx')({
  extension: /\.mdx$/
});

/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = withVanillaExtract(withMDX(nextConfig));
```

3/ (Optional) If you want to automatically generate debug IDs during development, you can add the [Babel](https://babeljs.io) plugin. Note that this step will cause Next.js to switch from [SWC](https://github.com/swc-project/swc) to Babel, increasing build times. This may or may not be an issue depending on the size of your project.

> Note: While optional for Next.js, the Babel plugin is still required when trying to run `.css.ts` files in Node for unit testing since the files are no longer being processed by a bundler.

If you don't have a `.babelrc` file in the root of your project, create one. Add the Babel plugin to your `.babelrc` file, ensuring that you're also including `"next/babel"` in your `presets` array.

```json
{
  "presets": ["next/babel"],
  "plugins": ["@vanilla-extract/babel-plugin"]
}
```

## Gatsby

To add to your [Gatsby](https://www.gatsbyjs.com) site, use the [gatsby-plugin-vanilla-extract](https://github.com/gatsby-uc/plugins/tree/main/packages/gatsby-plugin-vanilla-extract) plugin.

## Rollup

> Note: This option is useful for library development but not suitable for application bundles.
> Rollup has no built-in CSS bundling, so this plugin just outputs styles as individual CSS assets.
> For applications we instead recommend to use Vite
> (which itself uses Rollup under the hood but comes with its own CSS bundling).

1/ Install the dependencies.

```bash
npm install @vanilla-extract/css @vanilla-extract/rollup-plugin
```

2/ Add the [Rollup](https://rollupjs.org/) plugin to your Rollup config.

> ðŸ’¡ This plugin accepts an optional [configuration object](#configuration).

```js
import { vanillaExtractPlugin } from '@vanilla-extract/rollup-plugin';

// rollup.config.js
export default {
  plugins: [vanillaExtractPlugin(), ...]
}
```

This plugin works well with Rollup's `preserveModules`.

Rollup by default places assets in an "assets" directory.
You can configure [asset file names](https://rollupjs.org/guide/en/#outputassetfilenames)
if you care about CSS assets being placed right next to source files.

```js
  preserveModules: true,
  assetFileNames({ name }) {
    return name.replace(/^package-name\/src/, '');
  },
```

## Test environments

1/ Install the dependencies.

```bash
$ npm install @vanilla-extract/babel-plugin
```

2/ Add the [Babel](https://babeljs.io) plugin.

```json
{
  "plugins": ["@vanilla-extract/babel-plugin"]
}
```

3/ Disable runtime styles (Optional)

In testing environments (like `jsdom`) vanilla-extract will create and insert styles. While this is often desirable, it can be a major slowdown in your tests. If your tests donâ€™t require styles to be available, the `disableRuntimeStyles` import will disable all style creation.

```ts
// setupTests.ts
import '@vanilla-extract/css/disableRuntimeStyles';
```

## Configuration

### identifiers

Different formatting of identifiers (e.g. class names, keyframes, CSS Vars, etc) can be configured by selecting from the following options:

- `short` identifiers are a 7+ character hash. e.g. `hnw5tz3`
- `debug` identifiers contain human readable prefixes representing the owning filename and a potential rule level debug name. e.g. `myfile_mystyle_hnw5tz3`

Each integration will set a default value based on the configuration options passed to the bundler.
