import * as swc from '@swc/core';
export type FontDetail = { exportName: string; stubbedFamily: string };
export type NextFontTransformResult = {
  code: string;
  usedNextFont: boolean;
  details: FontDetail[];
  changed: boolean;
};

const HELPERS_PREAMBLE = [
  'const __VE_FONT_MSG = "next/font class names are generated by Turbopack and aren\'t available during vanilla-extract evaluation. Use style.* in VE files, and apply the real font\'s className/variable in runtime code.";',
  "function __ve_normalizeName(s){ return String(s).replace(/['\\\"]/g,''); }",
  'function __ve_toCssListRaw(items){ return items.map((s)=>__ve_normalizeName(s)); } ',
  "function __ve_buildFontFamily(family, fallback, includeVariant = true){ const base=__ve_normalizeName(family); const parts = [`'${base}'`]; if (includeVariant) parts.push(`'${base} Fallback'`); if (Array.isArray(fallback)) parts.push(...__ve_toCssListRaw(fallback)); return parts.join(', '); }",
  "function __ve_pickSingle(values){ const arr = Array.isArray(values) ? Array.from(new Set(values.filter(Boolean))) : (values!=null?[values]:[]); if (arr.length!==1) return undefined; const v = arr[0]; if (typeof v !== 'string') return v; if (v.includes(' ')) return undefined; return v; }",
  'function __veLocal(family, options = {}) {',
  '  const style = { fontFamily: __ve_buildFontFamily(String(family), options.fallback, true) };',
  // next/font/local does not expose top-level weight/style in style props
  '  return { get className(){ throw new Error(__VE_FONT_MSG); }, get variable(){ throw new Error(__VE_FONT_MSG); }, style };',
  '}',
  'function __veGoogle(fontName, options = {}) {',
  '  const family = String(fontName);',
  '  const style = { fontFamily: __ve_buildFontFamily(family, options.fallback, options.fallback == null) };',
  "  if (typeof options.weight === 'string' && options.weight && !options.weight.includes(' ')) { const n=Number(options.weight); if (!Number.isNaN(n)) style.fontWeight = n; } else if (typeof options.weight === 'number') { style.fontWeight = options.weight; }",
  '  const pickedStyle = __ve_pickSingle(options.style);',
  "  if (typeof pickedStyle === 'string' && pickedStyle && !pickedStyle.includes(' ')) { style.fontStyle = pickedStyle; } else if (options.style === undefined) { style.fontStyle = 'normal'; }",
  '  return { get className(){ throw new Error(__VE_FONT_MSG); }, get variable(){ throw new Error(__VE_FONT_MSG); }, style };',
  '}',
].join('\n');

function computeStubbedFamily(exportName: string, fallback?: string[]): string {
  const normalize = (s: string) => s.replace(/['\\\"]/g, '');
  const toCssList = (items: string[]) => items.map(normalize);
  const parts = toCssList([exportName, `${exportName} Fallback`]);
  if (Array.isArray(fallback)) parts.push(...toCssList(fallback));
  return parts.join(', ');
}

export async function transformNextFont(
  code: string,
  id: string,
): Promise<NextFontTransformResult> {
  const isTs = /\.(?:[cm]?ts|tsx)$/.test(id);
  const isTsx = /\.(?:tsx)$/.test(id);
  const isJsx = /\.(?:jsx)$/.test(id);

  const parseOptions: any = isTs
    ? {
        syntax: 'typescript',
        tsx: isTsx,
        dynamicImport: true,
        decorators: false,
      }
    : { syntax: 'ecmascript', jsx: isJsx, dynamicImport: true };

  const parseModule = async (src: string) =>
    swc.parse(src, {
      ...parseOptions,
      target: 'esnext',
      comments: false,
      script: false,
      isModule: true,
    });
  const printModule = async (mod: any) => {
    const { code: out } = await swc.print(mod, {
      minify: false,
      sourceMaps: false,
    });
    return out as string;
  };
  const printExpr = async (expr: any, programSpan: any): Promise<string> => {
    const mod = {
      type: 'Module',
      span: programSpan,
      body: [
        { type: 'ExpressionStatement', expression: expr, span: programSpan },
      ],
    } as any;
    const { code: out } = await swc.print(mod, {
      minify: false,
      sourceMaps: false,
    });
    return String(out).trim().replace(/;$/, '');
  };
  const parseExpr = async (exprCode: string): Promise<any> => {
    const m = await parseModule(`const __e = ${exprCode};`);
    const first = m.body && m.body[0];
    if (!first || first.type !== 'VariableDeclaration') return null;
    const d = first.declarations && first.declarations[0];
    return d && d.init ? d.init : null;
  };

  const program: any = await parseModule(code);
  const body: any[] = Array.isArray(program.body) ? [...program.body] : [];

  let localAlias: string | null = null;
  const googleSpecs: Array<{ local: string; pretty: string }> = [];
  let usedNextFont = false;
  let changed = false;
  const details: FontDetail[] = [];

  const newBody: any[] = [];
  for (const item of body) {
    if (item.type === 'ImportDeclaration') {
      const src = item.source && item.source.value;
      if (src === 'next/font/local') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportDefaultSpecifier') {
            localAlias = spec.local?.value || null;
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
      if (src === 'next/font/google') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportSpecifier') {
            const local = spec.local?.value;
            let importedName: string | undefined;
            if (spec.imported?.type === 'Identifier')
              importedName = spec.imported.value;
            if (spec.imported?.type === 'StringLiteral')
              importedName = spec.imported.value;
            if (!importedName) importedName = local;
            if (local && importedName) {
              googleSpecs.push({
                local,
                pretty: String(importedName).replace(/_/g, ' '),
              });
            }
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
    }
    newBody.push(item);
  }

  // Helper to parse snippet into ModuleItems
  const parseItems = async (snippet: string): Promise<any[]> => {
    if (!snippet.trim()) return [];
    const m = await parseModule(snippet);
    return m.body || [];
  };

  // Proxies for google fonts
  if (googleSpecs.length > 0) {
    const proxySrc = googleSpecs
      .map(
        ({ local, pretty }) =>
          `const ${local} = (...args) => __veGoogle(${JSON.stringify(
            pretty,
          )}, ...args);`,
      )
      .join('\n');
    const items = await parseItems(proxySrc);
    newBody.unshift(...items);
  }

  // Fallback alias for local alias to throw at runtime if called directly
  if (localAlias) {
    const aliasSrc = `const ${localAlias} = (..._args) => { throw new Error(__VE_FONT_MSG); };`;
    const items = await parseItems(aliasSrc);
    newBody.unshift(...items);
  }

  // Inject helpers at the very top if we touched next/font
  if (changed) {
    const helpersItems = await parseItems(HELPERS_PREAMBLE);
    newBody.unshift(...helpersItems);
  }

  // Utilities to find fallback arrays
  const isIdentifierNamed = (node: any, name: string) =>
    node && node.type === 'Identifier' && node.value === name;
  const toArrayOfStringLiterals = (node: any): string[] | undefined => {
    if (!node || node.type !== 'ArrayExpression') return undefined;
    const out: string[] = [];
    for (const el of node.elements || []) {
      if (!el) return undefined;
      const expr = (el as any).expression || el;
      if (!expr || expr.type !== 'StringLiteral') return undefined;
      out.push(String(expr.value));
    }
    return out;
  };
  const findFallbackInArgs = (args: any[]): string[] | undefined => {
    for (const arg of args || []) {
      const expr = arg.expression || arg;
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (!prop || prop.type !== 'Property') continue;
          const key = prop.key;
          let isFallback = false;
          if (key.type === 'Identifier' && key.value === 'fallback')
            isFallback = true;
          if (key.type === 'StringLiteral' && key.value === 'fallback')
            isFallback = true;
          if (isFallback) {
            const arr = toArrayOfStringLiterals(prop.value);
            if (arr) return arr;
          }
        }
      }
    }
    return undefined;
  };

  // Rewrite variable declarators
  const rewriteVarDecl = async (decl: any) => {
    for (const d of decl.declarations || []) {
      const init = d.init;
      if (!init || init.type !== 'CallExpression') continue;
      const callee = init.callee;
      const args = init.arguments || [];
      let varName = 'font';
      if (d.id && d.id.type === 'Identifier') varName = d.id.value;

      if (localAlias && isIdentifierNamed(callee, localAlias)) {
        // replace with __veLocal('Var', ...originalArgs)
        const full = await printExpr(init, program.span);
        const open = full.indexOf('(');
        const close = full.lastIndexOf(')');
        const argsCode =
          open >= 0 && close > open ? full.slice(open + 1, close).trim() : '';
        const callCode = `__veLocal(${JSON.stringify(varName)}${
          argsCode ? ', ' + argsCode : ''
        })`;
        const parsed = await parseExpr(callCode);
        if (parsed) d.init = parsed;
        const fb = findFallbackInArgs(args);
        details.push({
          exportName: varName,
          stubbedFamily: computeStubbedFamily(varName, fb),
        });
        changed = true;
        usedNextFont = true;
        continue;
      }

      if (callee && callee.type === 'Identifier') {
        const spec = googleSpecs.find((g) => g.local === callee.value);
        if (spec) {
          const full = await printExpr(init, program.span);
          const open = full.indexOf('(');
          const close = full.lastIndexOf(')');
          const argsCode =
            open >= 0 && close > open ? full.slice(open + 1, close).trim() : '';
          const callCode = `__veGoogle(${JSON.stringify(spec.pretty)}${
            argsCode ? ', ' + argsCode : ''
          })`;
          const parsed = await parseExpr(callCode);
          if (parsed) d.init = parsed;
          const fb = findFallbackInArgs(args);
          details.push({
            exportName: varName,
            stubbedFamily: computeStubbedFamily(spec.pretty, fb),
          });
          changed = true;
          usedNextFont = true;
          continue;
        }
      }
    }
  };

  for (const item of newBody) {
    if (item.type === 'VariableDeclaration') {
      await rewriteVarDecl(item);
    } else if (
      item.type === 'ExportDeclaration' &&
      item.declaration &&
      item.declaration.type === 'VariableDeclaration'
    ) {
      await rewriteVarDecl(item.declaration);
    }
  }

  const outCode = await printModule({
    type: 'Module',
    span: program.span,
    body: newBody,
  });
  return { code: outCode, usedNextFont, details, changed };
}
