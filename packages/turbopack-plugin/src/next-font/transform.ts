import * as swc from '@swc/core';
export type FontDetail = {
  exportName: string;
  stubbedFamily: string;
  stubbedWeight: number | undefined;
  stubbedStyle: string | undefined;
};
export type NextFontTransformResult = {
  code: string;
  usedNextFont: boolean;
  details: FontDetail[];
  changed: boolean;
};

const THROW_MSG =
  "next/font class names are generated by Turbopack and aren't available during vanilla-extract evaluation. Use style.* in VE files, and apply the real font's className/variable in runtime code.";

function computeStubbedFamily(
  exportName: string,
  fallback: string[] | undefined,
  isLocal: boolean,
): string {
  // Generic CSS font families that should not be quoted
  const genericFamilies = new Set([
    'serif',
    'sans-serif',
    'monospace',
    'cursive',
    'fantasy',
    'system-ui',
    'ui-serif',
    'ui-sans-serif',
    'ui-monospace',
    'ui-rounded',
    'emoji',
    'math',
    'fangsong',
  ]);

  const formatFamily = (s: string) => {
    // Remove existing quotes
    const clean = s.replace(/['"]/g, '');
    // Don't quote generic CSS font families
    if (genericFamilies.has(clean.toLowerCase())) {
      return clean;
    }
    // Quote everything else (custom fonts, fonts with spaces, etc.)
    return `'${clean}'`;
  };

  const parts = [formatFamily(exportName)];

  if (isLocal) {
    // Local fonts always include the generated fallback variant
    parts.push(formatFamily(`${exportName} Fallback`));
    // And then append any user-provided fallbacks
    if (Array.isArray(fallback)) {
      // Manual fallbacks are appended as-is (unquoted), mirroring Turbopack
      parts.push(...fallback);
    }
  } else {
    // Google fonts: if user fallbacks provided, use them; otherwise use '<Family> Fallback'
    if (Array.isArray(fallback)) {
      // Manual fallbacks are appended as-is (unquoted), mirroring Turbopack
      parts.push(...fallback);
    } else {
      parts.push(formatFamily(`${exportName} Fallback`));
    }
  }
  return parts.join(', ');
}

function computeStubbedWeight(weight: any): number | undefined {
  if (typeof weight === 'number') {
    return weight;
  }
  if (typeof weight === 'string' && weight && !weight.includes(' ')) {
    const n = Number(weight);
    if (!Number.isNaN(n)) {
      return n;
    }
  }
  return undefined;
}

function computeStubbedStyle(
  style: any,
  isGoogleFont: boolean,
): string | undefined {
  // If a single style string is provided, use it
  if (typeof style === 'string' && style && !style.includes(' ')) {
    return style;
  }
  // Arrays always resolve to undefined for both providers
  if (Array.isArray(style)) {
    return undefined;
  }
  // For Google fonts, missing style defaults to "normal"; local stays undefined
  if (style === undefined) {
    return isGoogleFont ? 'normal' : undefined;
  }
  return undefined;
}

export async function transformNextFont(
  code: string,
  id: string,
): Promise<NextFontTransformResult> {
  const isTs = /\.(?:[cm]?ts|tsx)$/.test(id);
  const isTsx = /\.(?:tsx)$/.test(id);
  const isJsx = /\.(?:jsx)$/.test(id);

  const parseOptions: any = isTs
    ? {
        syntax: 'typescript',
        tsx: isTsx,
        dynamicImport: true,
        decorators: false,
      }
    : { syntax: 'ecmascript', jsx: isJsx, dynamicImport: true };

  const parseModule = async (src: string) =>
    swc.parse(src, {
      ...parseOptions,
      target: 'esnext',
      comments: false,
      script: false,
      isModule: true,
    });
  const printModule = async (mod: any) => {
    const { code: out } = await swc.print(mod, {
      minify: false,
      sourceMaps: false,
    });
    return out as string;
  };
  const parseExpr = async (exprCode: string): Promise<any> => {
    const m = await parseModule(`const __e = ${exprCode};`);
    const first = m.body && m.body[0];
    if (!first || first.type !== 'VariableDeclaration') return null;
    const d = first.declarations && first.declarations[0];
    return d && d.init ? d.init : null;
  };

  const program: any = await parseModule(code);
  const body: any[] = Array.isArray(program.body) ? [...program.body] : [];

  let localAlias: string | null = null;
  const googleSpecs: Array<{ local: string; pretty: string }> = [];
  let usedNextFont = false;
  let changed = false;
  const details: FontDetail[] = [];

  const newBody: any[] = [];
  for (const item of body) {
    if (item.type === 'ImportDeclaration') {
      const src = item.source && item.source.value;
      if (src === 'next/font/local') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportDefaultSpecifier') {
            localAlias = spec.local?.value || null;
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
      if (src === 'next/font/google') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportSpecifier') {
            const local = spec.local?.value;
            let importedName: string | undefined;
            if (spec.imported?.type === 'Identifier')
              importedName = spec.imported.value;
            if (spec.imported?.type === 'StringLiteral')
              importedName = spec.imported.value;
            if (!importedName) importedName = local;
            if (local && importedName) {
              googleSpecs.push({
                local,
                pretty: String(importedName).replace(/_/g, ' '),
              });
            }
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
    }
    newBody.push(item);
  }

  // Note: We don't inject any helper functions anymore.
  // Instead, we'll compute values during the rewrite and inject them directly.

  // Utilities to find fallback arrays
  const isIdentifierNamed = (node: any, name: string) =>
    node && node.type === 'Identifier' && node.value === name;
  const unwrapExpr = (n: any) =>
    n && typeof n === 'object' && 'expression' in n ? (n as any).expression : n;
  const toArrayOfStringLiterals = (node: any): string[] | undefined => {
    node = unwrapExpr(node);
    if (!node || node.type !== 'ArrayExpression') return undefined;
    const out: string[] = [];
    for (const el of node.elements || []) {
      if (!el) return undefined;
      const expr = unwrapExpr(el);
      if (!expr || expr.type !== 'StringLiteral') return undefined;
      out.push(String(expr.value));
    }
    return out;
  };
  const findFallbackInArgs = (args: any[]): string[] | undefined => {
    for (const arg of args || []) {
      const expr = unwrapExpr(arg);
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (
            !prop ||
            (prop.type !== 'KeyValueProperty' && prop.type !== 'Property')
          )
            continue;
          const key = prop.key;
          let isFallback = false;
          if (key.type === 'Identifier' && key.value === 'fallback')
            isFallback = true;
          if (key.type === 'StringLiteral' && key.value === 'fallback')
            isFallback = true;
          if (isFallback) {
            const valNode: any =
              'value' in prop ? (prop as any).value : (prop as any).value;
            const arr = toArrayOfStringLiterals(unwrapExpr(valNode));
            if (arr) return arr;
          }
        }
      }
    }
    return undefined;
  };

  const isLocalSrcSingleString = (args: any[]): boolean => {
    for (const arg of args || []) {
      const expr = unwrapExpr(arg);
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (
            !prop ||
            (prop.type !== 'KeyValueProperty' && prop.type !== 'Property')
          )
            continue;
          const key = prop.key;
          let isSrc = false;
          if (key.type === 'Identifier' && key.value === 'src') isSrc = true;
          if (key.type === 'StringLiteral' && key.value === 'src') isSrc = true;
          if (isSrc) {
            const valNode: any =
              'value' in prop ? (prop as any).value : (prop as any).value;
            const val = unwrapExpr(valNode);
            return val?.type === 'StringLiteral';
          }
        }
      }
    }
    return false;
  };

  const findWeightInArgs = (args: any[]): any => {
    for (const arg of args || []) {
      const expr = unwrapExpr(arg);
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (
            !prop ||
            (prop.type !== 'KeyValueProperty' && prop.type !== 'Property')
          )
            continue;
          const key = prop.key;
          let isWeight = false;
          if (key.type === 'Identifier' && key.value === 'weight')
            isWeight = true;
          if (key.type === 'StringLiteral' && key.value === 'weight')
            isWeight = true;
          if (isWeight) {
            const valNode: any =
              'value' in prop ? (prop as any).value : (prop as any).value;
            const val = unwrapExpr(valNode);
            if (val.type === 'NumericLiteral') return val.value;
            if (val.type === 'StringLiteral') return val.value;
            return undefined;
          }
        }
      }
    }
    return undefined;
  };

  const findStyleInArgs = (args: any[]): any => {
    for (const arg of args || []) {
      const expr = unwrapExpr(arg);
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (
            !prop ||
            (prop.type !== 'KeyValueProperty' && prop.type !== 'Property')
          )
            continue;
          const key = prop.key;
          let isStyle = false;
          if (key.type === 'Identifier' && key.value === 'style')
            isStyle = true;
          if (key.type === 'StringLiteral' && key.value === 'style')
            isStyle = true;
          if (isStyle) {
            const valNode: any =
              'value' in prop ? (prop as any).value : (prop as any).value;
            const val = unwrapExpr(valNode);
            if (val.type === 'StringLiteral') return val.value;
            if (val.type === 'ArrayExpression') {
              const arr = toArrayOfStringLiterals(val);
              return arr;
            }
            return undefined;
          }
        }
      }
    }
    return undefined;
  };

  // Rewrite variable declarators
  const rewriteVarDecl = async (decl: any) => {
    for (const d of decl.declarations || []) {
      const init = d.init;
      if (!init || init.type !== 'CallExpression') continue;
      const callee = init.callee;
      const args = init.arguments || [];
      let varName = 'font';
      if (d.id && d.id.type === 'Identifier') varName = d.id.value;

      if (localAlias && isIdentifierNamed(callee, localAlias)) {
        // compute the font family for local font
        const fb = findFallbackInArgs(args);
        const weight = findWeightInArgs(args);
        const style = findStyleInArgs(args);
        const singleSrcString = isLocalSrcSingleString(args);

        const computedFamily = computeStubbedFamily(varName, fb, true);
        const computedWeight = singleSrcString
          ? computeStubbedWeight(weight)
          : undefined;
        const computedStyle = singleSrcString
          ? computeStubbedStyle(style, false)
          : undefined; // false = not a Google font

        details.push({
          exportName: varName,
          stubbedFamily: computedFamily,
          stubbedWeight: computedWeight,
          stubbedStyle: computedStyle,
        });

        // build the style object with only defined properties
        const styleProps: string[] = [
          `fontFamily: ${JSON.stringify(computedFamily)}`,
        ];
        if (computedWeight !== undefined) {
          styleProps.push(`fontWeight: ${computedWeight}`);
        }
        if (computedStyle !== undefined) {
          styleProps.push(`fontStyle: ${JSON.stringify(computedStyle)}`);
        }

        // inject the computed value directly as an object literal
        const stubCode = `{ 
          get className() { throw new Error(${JSON.stringify(THROW_MSG)}); }, 
          get variable() { throw new Error(${JSON.stringify(THROW_MSG)}); }, 
          style: { ${styleProps.join(', ')} } 
        }`;
        const parsed = await parseExpr(stubCode);
        if (parsed) d.init = parsed;

        changed = true;
        usedNextFont = true;
        continue;
      }

      if (callee && callee.type === 'Identifier') {
        const spec = googleSpecs.find((g) => g.local === callee.value);
        if (spec) {
          // compute all the values for google font
          const fb = findFallbackInArgs(args);
          const weight = findWeightInArgs(args);
          const style = findStyleInArgs(args);

          const computedFamily = computeStubbedFamily(spec.pretty, fb, false);
          const computedWeight = computeStubbedWeight(weight);
          const computedStyle = computeStubbedStyle(style, true); // true = Google font

          details.push({
            exportName: varName,
            stubbedFamily: computedFamily,
            stubbedWeight: computedWeight,
            stubbedStyle: computedStyle,
          });

          // build the style object with only defined properties
          const styleProps: string[] = [
            `fontFamily: ${JSON.stringify(computedFamily)}`,
          ];
          if (computedWeight !== undefined) {
            styleProps.push(`fontWeight: ${computedWeight}`);
          }
          if (computedStyle !== undefined) {
            styleProps.push(`fontStyle: ${JSON.stringify(computedStyle)}`);
          }

          // inject the computed value directly as an object literal
          const stubCode = `{ 
            get className() { throw new Error(${JSON.stringify(THROW_MSG)}); }, 
            get variable() { throw new Error(${JSON.stringify(THROW_MSG)}); }, 
            style: { ${styleProps.join(', ')} } 
          }`;
          const parsed = await parseExpr(stubCode);
          if (parsed) d.init = parsed;

          changed = true;
          usedNextFont = true;
          continue;
        }
      }
    }
  };

  for (const item of newBody) {
    if (item.type === 'VariableDeclaration') {
      await rewriteVarDecl(item);
    } else if (
      item.type === 'ExportDeclaration' &&
      item.declaration &&
      item.declaration.type === 'VariableDeclaration'
    ) {
      await rewriteVarDecl(item.declaration);
    }
  }

  const outCode = await printModule({
    type: 'Module',
    span: program.span,
    body: newBody,
  });
  return { code: outCode, usedNextFont, details, changed };
}
