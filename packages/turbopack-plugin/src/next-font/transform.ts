import * as swc from '@swc/core';

export type NextFontTransformResult = {
  code: string;
  map: string | null;
};

const THROW_MSG =
  "next/font class names are generated by Turbopack and aren't available during vanilla-extract evaluation. Use style.* in VE files, and apply the real font's className/variable in runtime code.";

const GENERIC_FAMILIES = new Set([
  'serif',
  'sans-serif',
  'monospace',
  'cursive',
  'fantasy',
  'system-ui',
  'ui-serif',
  'ui-sans-serif',
  'ui-monospace',
  'ui-rounded',
  'emoji',
  'math',
  'fangsong',
]);

// --- Helpers ---

function formatFontFamily(name: string): string {
  const clean = name.replace(/['"]/g, '');
  return GENERIC_FAMILIES.has(clean.toLowerCase()) ? clean : `'${clean}'`;
}

function getFontFamily(
  baseName: string,
  fallbacks: string[] | undefined,
  isLocal: boolean,
): string {
  const parts = [formatFontFamily(baseName)];

  // Local fonts always get a generated fallback. Google fonts get it if no user fallbacks.
  // Original logic:
  // Local: [Name, Name Fallback, ...UserFallbacks]
  // Google: [Name, ...UserFallbacks] OR [Name, Name Fallback]
  if (isLocal) {
    parts.push(formatFontFamily(`${baseName} Fallback`));
    if (fallbacks) parts.push(...fallbacks);
  } else {
    if (fallbacks && fallbacks.length > 0) {
      parts.push(...fallbacks);
    } else {
      parts.push(formatFontFamily(`${baseName} Fallback`));
    }
  }

  return parts.join(', ');
}

function parseWeight(weight: any): number | undefined {
  if (typeof weight === 'number') return weight;
  if (typeof weight === 'string' && weight && !weight.includes(' ')) {
    const n = Number(weight);
    if (!Number.isNaN(n)) return n;
  }
  return undefined;
}

function parseStyle(style: any, isGoogle: boolean): string | undefined {
  if (Array.isArray(style)) return undefined;
  if (typeof style === 'string' && style && !style.includes(' ')) return style;
  return isGoogle ? 'normal' : undefined;
}

// --- AST Utilities ---

type FontOptions = {
  src?: any;
  weight?: any;
  style?: any;
  fallback?: string[];
};

/**
 * Extract simple values from AST nodes (literals, arrays of literals).
 * Returns `undefined` if too complex.
 */
function unwrapValue(node: any): any {
  if (!node) return undefined;

  // Handle basic literals
  if (node.type === 'StringLiteral' || node.type === 'NumericLiteral') {
    return node.value;
  }

  // Handle arrays
  if (node.type === 'ArrayExpression') {
    return node.elements
      .map((el: any) => unwrapValue(el?.expression || el))
      .filter((v: any) => v !== undefined);
  }

  return undefined;
}

/**
 * Extracts the configuration object from the first argument of a call.
 */
function extractFontOptions(args: any[]): FontOptions {
  const options: FontOptions = {};
  const configNode = args[0]?.expression;

  if (configNode?.type !== 'ObjectExpression') {
    return options;
  }

  for (const prop of configNode.properties) {
    if (prop.type !== 'KeyValueProperty' && prop.type !== 'Property') continue;

    const key = prop.key.value || prop.key.name; // Handle StringLiteral or Identifier keys
    const value = unwrapValue(prop.value);

    if (key === 'src') options.src = value;
    if (key === 'weight') options.weight = value;
    if (key === 'style') options.style = value;
    if (key === 'fallback') options.fallback = value;
  }

  return options;
}

// --- Main Transform ---

export async function transformNextFont(
  code: string,
  filename: string,
): Promise<NextFontTransformResult> {
  // 1. Parse
  const isTs = /\.(?:[cm]?ts|tsx)$/.test(filename);
  const isTsx = /\.tsx$/.test(filename);
  const isJsx = /\.jsx$/.test(filename);

  const module = await swc.parse(code, {
    syntax: isTs ? 'typescript' : 'ecmascript',
    tsx: isTsx,
    jsx: isJsx,
    dynamicImport: true,
    decorators: false,
    target: 'esnext',
    comments: false,
    script: false,
  });

  const imports = new Map<string, { type: 'local' | 'google'; name: string }>();
  let changed = false;

  // 2. Scan imports & filter body
  const newBody = [];

  for (const item of module.body) {
    if (item.type === 'ImportDeclaration') {
      const source = item.source.value;
      if (source === 'next/font/local') {
        item.specifiers.forEach((s) => {
          if (s.type === 'ImportDefaultSpecifier') {
            imports.set(s.local.value, { type: 'local', name: 'local' });
          }
        });
        changed = true;
        continue; // Remove import
      }
      if (source === 'next/font/google') {
        item.specifiers.forEach((s) => {
          if (s.type === 'ImportSpecifier') {
            const local = s.local.value;
            const imported = s.imported?.value || local;
            imports.set(local, {
              type: 'google',
              name: imported.replace(/_/g, ' '),
            });
          }
        });
        changed = true;
        continue; // Remove import
      }
    }
    newBody.push(item);
  }

  const usedNextFont = changed;
  if (!usedNextFont) {
    return { code, map: null };
  }

  // 3. Transform Declarations
  // We need to parse the stub object asynchronously, so we create a helper.
  const createStubNode = async (
    family: string,
    weight: number | undefined,
    style: string | undefined,
  ) => {
    const styleObj = [
      `fontFamily: ${JSON.stringify(family)}`,
      weight !== undefined ? `fontWeight: ${weight}` : null,
      style !== undefined ? `fontStyle: ${JSON.stringify(style)}` : null,
    ]
      .filter(Boolean)
      .join(', ');

    const stubSource = `({
      get className() { throw new Error(${JSON.stringify(THROW_MSG)}); },
      get variable() { throw new Error(${JSON.stringify(THROW_MSG)}); },
      style: { ${styleObj} }
    })`;

    // Parse this tiny snippet to get an Expression node
    const m = await swc.parse(stubSource, { syntax: 'ecmascript' });
    return (m.body[0] as any).expression;
  };

  const processDeclarator = async (decl: any) => {
    if (!decl.init || decl.init.type !== 'CallExpression') return;

    const callee = decl.init.callee;
    if (callee.type !== 'Identifier') return;

    const fontDef = imports.get(callee.value);
    if (!fontDef) return;

    const args = decl.init.arguments || [];
    const opts = extractFontOptions(args);
    const varName = decl.id.value || 'font';

    const isGoogle = fontDef.type === 'google';
    const familyName = isGoogle ? fontDef.name : varName;

    const family = getFontFamily(familyName, opts.fallback, !isGoogle);
    let weight = parseWeight(opts.weight);
    let style = parseStyle(opts.style, isGoogle);

    // Local fonts only stub weight/style if src is a simple string
    if (!isGoogle && typeof opts.src !== 'string') {
      weight = undefined;
      style = undefined;
    }

    decl.init = await createStubNode(family, weight, style);
  };

  for (const item of newBody) {
    if (item.type === 'VariableDeclaration') {
      for (const decl of item.declarations) {
        await processDeclarator(decl);
      }
    } else if (
      item.type === 'ExportDeclaration' &&
      item.declaration.type === 'VariableDeclaration'
    ) {
      for (const decl of item.declaration.declarations) {
        await processDeclarator(decl);
      }
    }
  }

  // 4. Generate Code
  const { code: outputCode, map } = await swc.print(
    { ...module, body: newBody },
    { minify: false, sourceMaps: true },
  );

  return {
    code: outputCode,
    map: map || null,
  };
}
