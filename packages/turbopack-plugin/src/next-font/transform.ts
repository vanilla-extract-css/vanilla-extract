import * as swc from '@swc/core';
export type FontDetail = { exportName: string; stubbedFamily: string };
export type NextFontTransformResult = {
  code: string;
  usedNextFont: boolean;
  details: FontDetail[];
  changed: boolean;
};

const HELPERS_PREAMBLE = [
  "const __VE_FONT_MSG = \"next/font class names are generated by Turbopack and aren't available during vanilla-extract evaluation. Use style.* in VE files, and apply the real font's className/variable in runtime code.\";",
  "function __ve_toQuotedList(items){return items.map((s)=>`'${s.replace(/['\\\"]/g,'')}'`);} ",
  "function __ve_buildFontFamily(family, fallback){ const parts = __ve_toQuotedList([family, family + ' Fallback']); if (Array.isArray(fallback)) parts.push(...__ve_toQuotedList(fallback)); return parts.join(', '); }",
  "function __ve_pickSingle(values){ const arr = Array.isArray(values) ? Array.from(new Set(values.filter(Boolean))) : (values!=null?[values]:[]); if (arr.length!==1) return undefined; const v = arr[0]; if (typeof v !== 'string') return v; if (v.includes(' ')) return undefined; return v; }",
  'function __veLocal(family, options = {}) {',
  "  const style = { fontFamily: __ve_buildFontFamily(String(family), options.fallback) };",
  "  let weight = __ve_pickSingle(options.weight); if (!weight && Array.isArray(options.src)) weight = __ve_pickSingle(options.src.map((s)=>s&&s.weight));",
  "  if (typeof weight === 'string' && weight && !weight.includes(' ')) { const n=Number(weight); if (!Number.isNaN(n)) style.fontWeight = n; } else if (typeof weight === 'number') { style.fontWeight = weight; }",
  "  let fstyle = __ve_pickSingle(options.style); if (!fstyle && Array.isArray(options.src)) fstyle = __ve_pickSingle(options.src.map((s)=>s&&s.style));",
  "  if (typeof fstyle === 'string' && fstyle && !fstyle.includes(' ')) { style.fontStyle = fstyle; }",
  "  return { get className(){ throw new Error(__VE_FONT_MSG); }, get variable(){ throw new Error(__VE_FONT_MSG); }, style };",
  '}',
  'function __veGoogle(fontName, options = {}) {',
  '  const family = String(fontName);',
  "  const style = { fontFamily: __ve_buildFontFamily(family, options.fallback) };",
  "  if (typeof options.weight === 'string' && options.weight && !options.weight.includes(' ')) { const n=Number(options.weight); if (!Number.isNaN(n)) style.fontWeight = n; } else if (typeof options.weight === 'number') { style.fontWeight = options.weight; }",
  "  if (typeof options.style === 'string' && options.style && !options.style.includes(' ')) { style.fontStyle = options.style; }",
  "  return { get className(){ throw new Error(__VE_FONT_MSG); }, get variable(){ throw new Error(__VE_FONT_MSG); }, style };",
  '}',
].join('\n');

function computeStubbedFamily(exportName: string, fallback?: string[]): string {
  const toQuotedList = (items: string[]) => items.map((s) => `'${s.replace(/['\\\"]/g, '')}'`);
  const parts = toQuotedList([exportName, `${exportName} Fallback`]);
  if (Array.isArray(fallback)) parts.push(...toQuotedList(fallback));
  return parts.join(', ');
}


export async function transformNextFont(
  code: string,
  id: string,
): Promise<NextFontTransformResult> {
  try {
  const isTs = /\.(?:[cm]?ts|tsx)$/.test(id);
  const isTsx = /\.(?:tsx)$/.test(id);
  const isJsx = /\.(?:jsx)$/.test(id);

  const parseOptions: any = isTs
    ? { syntax: 'typescript', tsx: isTsx, dynamicImport: true, decorators: false }
    : { syntax: 'ecmascript', jsx: isJsx, dynamicImport: true };

  const parseModule = async (src: string) => swc.parse(src, { ...parseOptions, target: 'esnext', comments: false, script: false, isModule: true });
  const printModule = async (mod: any) => {
    const { code: out } = await swc.print(mod, { minify: false, sourceMaps: false });
    return out as string;
  };
  const printExpr = async (expr: any, programSpan: any): Promise<string> => {
    const mod = { type: 'Module', span: programSpan, body: [{ type: 'ExpressionStatement', expression: expr, span: programSpan }] } as any;
    const { code: out } = await swc.print(mod, { minify: false, sourceMaps: false });
    return String(out).trim().replace(/;$/, '');
  };
  const parseExpr = async (exprCode: string): Promise<any> => {
    const m = await parseModule(`const __e = ${exprCode};`);
    const first = m.body && m.body[0];
    if (!first || first.type !== 'VariableDeclaration') return null;
    const d = first.declarations && first.declarations[0];
    return d && d.init ? d.init : null;
  };

  const program: any = await parseModule(code);
  const body: any[] = Array.isArray(program.body) ? [...program.body] : [];

  let localAlias: string | null = null;
  const googleSpecs: Array<{ local: string; pretty: string }> = [];
  let usedNextFont = false;
  let changed = false;
  const details: FontDetail[] = [];

  const newBody: any[] = [];
  for (const item of body) {
    if (item.type === 'ImportDeclaration') {
      const src = item.source && item.source.value;
      if (src === 'next/font/local') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportDefaultSpecifier') {
            localAlias = spec.local?.value || null;
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
      if (src === 'next/font/google') {
        for (const spec of item.specifiers || []) {
          if (spec.type === 'ImportSpecifier') {
            const local = spec.local?.value;
            let importedName: string | undefined;
            if (spec.imported?.type === 'Identifier') importedName = spec.imported.value;
            if (spec.imported?.type === 'StringLiteral') importedName = spec.imported.value;
            if (!importedName) importedName = local;
            if (local && importedName) {
              googleSpecs.push({ local, pretty: String(importedName).replace(/_/g, ' ') });
            }
          }
        }
        usedNextFont = true;
        changed = true;
        continue; // drop the import
      }
    }
    newBody.push(item);
  }

  // Helper to parse snippet into ModuleItems
  const parseItems = async (snippet: string): Promise<any[]> => {
    if (!snippet.trim()) return [];
    const m = await parseModule(snippet);
    return m.body || [];
  };

  // Proxies for google fonts
  if (googleSpecs.length > 0) {
    const proxySrc = googleSpecs
      .map(({ local, pretty }) => `const ${local} = (...args) => __veGoogle(${JSON.stringify(pretty)}, ...args);`)
      .join('\n');
    const items = await parseItems(proxySrc);
    newBody.unshift(...items);
  }

  // Fallback alias for local alias to throw at runtime if called directly
  if (localAlias) {
    const aliasSrc = `const ${localAlias} = (..._args) => { throw new Error(__VE_FONT_MSG); };`;
    const items = await parseItems(aliasSrc);
    newBody.unshift(...items);
  }

  // Inject helpers at the very top if we touched next/font
  if (changed) {
    const helpersItems = await parseItems(HELPERS_PREAMBLE);
    newBody.unshift(...helpersItems);
  }

  // Utilities to find fallback arrays
  const isIdentifierNamed = (node: any, name: string) => node && node.type === 'Identifier' && node.value === name;
  const toArrayOfStringLiterals = (node: any): string[] | undefined => {
    if (!node || node.type !== 'ArrayExpression') return undefined;
    const out: string[] = [];
    for (const el of node.elements || []) {
      if (!el) return undefined;
      const expr = (el as any).expression || el;
      if (!expr || expr.type !== 'StringLiteral') return undefined;
      out.push(String(expr.value));
    }
    return out;
  };
  const findFallbackInArgs = (args: any[]): string[] | undefined => {
    for (const arg of args || []) {
      const expr = arg.expression || arg;
      if (!expr) continue;
      if (expr.type === 'ObjectExpression') {
        for (const prop of expr.properties || []) {
          if (!prop || prop.type !== 'Property') continue;
          const key = prop.key;
          let isFallback = false;
          if (key.type === 'Identifier' && key.value === 'fallback') isFallback = true;
          if (key.type === 'StringLiteral' && key.value === 'fallback') isFallback = true;
          if (isFallback) {
            const arr = toArrayOfStringLiterals(prop.value);
            if (arr) return arr;
          }
        }
      }
    }
    return undefined;
  };

  // Rewrite variable declarators
  const rewriteVarDecl = async (decl: any) => {
    for (const d of decl.declarations || []) {
      const init = d.init;
      if (!init || init.type !== 'CallExpression') continue;
      const callee = init.callee;
      const args = init.arguments || [];
      let varName = 'font';
      if (d.id && d.id.type === 'Identifier') varName = d.id.value;

      if (localAlias && isIdentifierNamed(callee, localAlias)) {
        // replace with __veLocal('Var', ...originalArgs)
        const full = await printExpr(init, program.span);
        const open = full.indexOf('(');
        const close = full.lastIndexOf(')');
        const argsCode = open >= 0 && close > open ? full.slice(open + 1, close).trim() : '';
        const callCode = `__veLocal(${JSON.stringify(varName)}${argsCode ? ', ' + argsCode : ''})`;
        const parsed = await parseExpr(callCode);
        if (parsed) d.init = parsed;
        const fb = findFallbackInArgs(args);
        details.push({ exportName: varName, stubbedFamily: computeStubbedFamily(varName, fb) });
        changed = true;
        usedNextFont = true;
        continue;
      }

      if (callee && callee.type === 'Identifier') {
        const spec = googleSpecs.find((g) => g.local === callee.value);
        if (spec) {
          const full = await printExpr(init, program.span);
          const open = full.indexOf('(');
          const close = full.lastIndexOf(')');
          const argsCode = open >= 0 && close > open ? full.slice(open + 1, close).trim() : '';
          const callCode = `__veGoogle(${JSON.stringify(spec.pretty)}${argsCode ? ', ' + argsCode : ''})`;
          const parsed = await parseExpr(callCode);
          if (parsed) d.init = parsed;
          const fb = findFallbackInArgs(args);
          details.push({ exportName: varName, stubbedFamily: computeStubbedFamily(spec.pretty, fb) });
          changed = true;
          usedNextFont = true;
          continue;
        }
      }
    }
  };

  for (const item of newBody) {
    if (item.type === 'VariableDeclaration') {
      await rewriteVarDecl(item);
    } else if (item.type === 'ExportDeclaration' && item.declaration && item.declaration.type === 'VariableDeclaration') {
      await rewriteVarDecl(item.declaration);
    }
  }

  const outCode = await printModule({ type: 'Module', span: program.span, body: newBody });
  return { code: outCode, usedNextFont, details, changed };
  } catch {
    // Fallback to regex-based transform if SWC parsing/manipulation fails
    return (function regexTransformNextFontFallback(code: string): NextFontTransformResult {
      if (!code.includes('next/font')) {
        return { code, usedNextFont: false, details: [], changed: false };
      }

      let transformed = code;
      let changed = false;
      let usesNextFont = false;
      const details: FontDetail[] = [];

      const localAliases: string[] = [];
      const localImportRe = /import\s+([A-Za-z_$][\w$]*)\s*(?:,\s*\{[^}]*\}\s*)?from\s*["']next\/font\/local["']/g;
      transformed = transformed.replace(localImportRe, (_m, alias) => {
        if (alias) localAliases.push(String(alias));
        usesNextFont = true;
        changed = true;
        return '';
      });

      for (const callee of localAliases) {
        const declAnyArgsRe = new RegExp(
          `(export\\s+)?(const|let|var)\\s+([A-Za-z_$][\\w$]*)(?:\\s*:\\s*[^=]+?)?\\s*=\\s*${callee}\\s*\\(`,
          'g',
        );
        transformed = transformed.replace(declAnyArgsRe, (_m, exp, kind, name) => {
          changed = true;
          const expPrefix = exp || '';
          return `${expPrefix}${kind} ${name} = __veLocal(${JSON.stringify(String(name))}, `;
        });

        const leftoverCall = new RegExp(`\\b${callee}\\s*\\(`);
        if (leftoverCall.test(transformed)) {
          const fallback = `\nconst ${callee} = (..._args) => { throw new Error(__VE_FONT_MSG); };\n`;
          transformed = fallback + transformed;
          changed = true;
        }
      }

      const googleSpecs: Array<{ local: string; orig: string }> = [];
      const googleImportRe = /import\s*\{([^}]+)\}\s*from\s*["']next\/font\/google["']/g;
      for (const m of transformed.matchAll(googleImportRe)) {
        const inside = m && m[1] ? m[1] : '';
        if (!inside) continue;
        usesNextFont = true;
        const specs = inside
          .split(',')
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        for (const spec of specs) {
          const m2 = spec.match(/^([A-Za-z_$][\w$]*)(?:\s+as\s+([A-Za-z_$][\w$]*))?$/);
          if (m2 && m2[1]) {
            const orig = m2[1];
            const local = m2[2] || m2[1];
            googleSpecs.push({ local: String(local), orig: String(orig) });
          }
        }
      }
      if (googleSpecs.length > 0) {
        transformed = transformed.replace(googleImportRe, '');
        changed = true;
        const proxyDefs = googleSpecs
          .map(({ local, orig }) => `const ${local} = (...args) => __veGoogle(${JSON.stringify(orig.replace(/_/g, ' '))}, ...args);`)
          .join('\n');
        transformed = `${proxyDefs}\n${transformed}`;
      }

      if (changed && !/^\s*const\s+__VE_FONT_MSG\s*=/.test(transformed)) {
        transformed = `${HELPERS_PREAMBLE}\n${transformed}`;
      }

      return { code: transformed, usedNextFont: usesNextFont, details, changed };
    })(code);
  }
}
